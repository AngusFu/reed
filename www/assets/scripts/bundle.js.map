{"version":3,"file":null,"sources":["../../../node_modules/rxjs/src/util/isFunction.ts","../../../node_modules/rxjs/src/util/isObject.ts","../../../node_modules/rxjs/src/util/tryCatch.ts","../../../node_modules/rxjs/src/util/toSubscriber.ts","../../../node_modules/rxjs/src/symbol/observable.ts","../../../node_modules/rxjs/src/util/root.ts","../../../node_modules/rxjs/src/util/isArray.ts","../../../node_modules/rxjs/src/util/errorObject.ts","../../../node_modules/rxjs/src/util/UnsubscriptionError.ts","../../../node_modules/rxjs/src/Subscription.ts","../../../node_modules/rxjs/src/Observer.ts","../../../node_modules/rxjs/src/symbol/rxSubscriber.ts","../../../node_modules/rxjs/src/Subscriber.ts","../../../node_modules/rxjs/src/Observable.ts","../../../src/app/app.component.ts","../../../src/app/rate/rate.component.ts","../../../src/app/app.module.ts","../../../src/main.ts"],"sourcesContent":["export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","import { Subscriber } from '../Subscriber';\nimport { $$rxSubscriber } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[$$rxSubscriber]) {\n      return nextOrObserver[$$rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const $$observable = getSymbolObservable(root);","declare let global: NodeJS.Global;\n\ndeclare module NodeJS {\n  interface Global {\n    window: any;\n    global: any;\n  }\n}\n\n/**\n * window: browser in DOM main thread\n * self: browser in WebWorker\n * global: Node.js/other\n */\nexport const root: any = (\n     typeof window == 'object' && window.window === window && window\n  || typeof self == 'object' && self.self === self && self\n  || typeof global == 'object' && global.global === global && global\n);\n\nif (!root) {\n  throw new Error('RxJS could not find any global context (window, self, global)');\n}\n","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport var errorObject: any = { e: {} };","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const { _unsubscribe, _subscriptions } = (<any> this);\n\n    (<any> this)._subscriptions = null;\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        (errors = errors || []).push(errorObject.e);\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      let index = -1;\n      const len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(err.errors);\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let sub = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        sub = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (sub.closed || typeof sub.unsubscribe !== 'function') {\n          break;\n        } else if (this.closed) {\n          sub.unsubscribe();\n        } else {\n          ((<any> this)._subscriptions || ((<any> this)._subscriptions = [])).push(sub);\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    return sub;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n\n    // HACK: This might be redundant because of the logic in `add()`\n    if (subscription == null   || (\n        subscription === this) || (\n        subscription === Subscription.EMPTY)) {\n      return;\n    }\n\n    const subscriptions = (<any> this)._subscriptions;\n\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n}\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const $$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { $$rxSubscriber } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [$$rxSubscriber]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.destination = (<Subscriber<any>> destinationOrNext);\n            (<any> this.destination).add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parent: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      context = observerOrNext;\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (isFunction(context.unsubscribe)) {\n        this.add(<() => void> context.unsubscribe.bind(context));\n      }\n      context.unsubscribe = this.unsubscribe.bind(this);\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parent } = this;\n      if (!_parent.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parent, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parent } = this;\n      if (this._error) {\n        if (!_parent.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parent, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parent.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parent.syncErrorValue = err;\n        _parent.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parent } = this;\n      if (this._complete) {\n        if (!_parent.syncErrorThrowable) {\n          this.__tryOrUnsub(this._complete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parent, this._complete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  protected _unsubscribe(): void {\n    const { _parent } = this;\n    this._context = null;\n    this._parent = null;\n    _parent.unsubscribe();\n  }\n}\n","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { $$observable } from './symbol/observable';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  protected source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is  called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: <R>(this: Observable<T>, subscriber: Subscriber<R>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: <R>(subscriber: Subscriber<R>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  /**\n   * Registers handlers for handling emitted values, error and completions from the observable, and\n   *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n   * @method subscribe\n   * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n   * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled\n   * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   */\n  subscribe(): Subscription;\n  subscribe(observer: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this);\n    } else {\n      sink.add(this._subscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      const subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [$$observable]() {\n    return this;\n  }\n}\n","import { Component } from '@angular/core';\n\nimport { Observable } from 'rxjs/Observable'\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  state = {\n    rate: 3,\n    rateText: ['完全不同意', '不太同意', '说不清楚', '比较符合', '完全符合']\n  };\n  constructor() {\n    console.log(Observable);\n  }\n}\n","import {\n  Component,\n  OnInit,\n  Input,\n  Output,\n  EventEmitter\n} from '@angular/core';\n\n@Component({\n  selector: 'rate',\n  templateUrl: './rate.component.html',\n  styleUrls: [\n    './rate.component.scss',\n    './rate.component.scss'\n  ]\n})\nexport class RateComponent implements OnInit {\n  // 默认的分值\n  rateVal: number = 0;\n  // 用于 mouseover 记住 rateVal\n  rateMemo: number = 0;\n  // label 文本\n  rateText: string[] | number[] = ['极差', '失望', '一般', '满意', '惊喜'];\n  // 是否显示 label\n  showLabel = false;\n  isReadonly = false;\n\n  /**\n   * 评分  rate\n   */\n  @Output() rateChange = new EventEmitter();\n\n  @Input() get rate() {\n    let val = this.rateVal;\n    val = val < 0 ? 0 : (val > 5 ? 5 : val);\n    return val;\n  }\n\n  set rate(val: number) {\n    this.rateVal = val;\n    this.rateChange.emit(this.rateVal);\n  }\n\n  /**\n   * 自定义文本 text\n   */\n  @Input() get text() {\n    return this.rateText;\n  };\n\n  set text(text) {\n    this.showLabel = text !== void 0 && text !== null;\n    this.rateText = !this.showLabel ? null : (text || this.rateText);\n  }\n\n  /**\n   * readonly\n   */\n  @Input() get readonly() {\n    return this.isReadonly;\n  }\n\n  set readonly(readonly) {\n    this.isReadonly = readonly !== void 0 && String(readonly) !== 'false';\n  }\n\n  click(rate: number, e: MouseEvent) {\n    e.preventDefault();\n    this.rate = rate;\n    this.rateMemo = this.rate;\n  }\n\n  mouseenter(i: number) {\n    this.rateMemo = this.rate;\n    this.rateVal = i;\n  }\n\n  mouseleave(i: number) {\n    this.rate = this.rateMemo;\n  }\n\n  constructor() {}\n\n  ngOnInit() {}\n}\n\n","import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HttpModule } from '@angular/http';\n\nimport { AppComponent } from './app.component';\nimport { RateComponent } from './rate/rate.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    RateComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n","// development mode only\n// just bundle polyfills and @angular/*\n// in seperate for performance concern\n// this can make rollup response to changes\n// faster ever\n// import './polyfills.ts';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n"],"names":["x","tryCatchTarget","apply","this","arguments","e","errorObject_1","fn","tryCatcher","nextOrObserver","error","complete","Subscriber_1","rxSubscriber_1","Observer_1","context","$$observable","Symbol","observable","exports","window","self","global","Error","Array","isArray","length","errors","_super","err","call","map","i","toString","join","name","stack","message","__extends","unsubscribe","_unsubscribe","Subscription","hasErrors","closed","_a","_subscriptions","isFunction_1","trial","tryCatch_1","push","isArray_1","index","len","sub","isObject_1","UnsubscriptionError_1","concat","teardown","EMPTY","subscription","subscriptions","subscriptionIndex","indexOf","splice","empty","next","value","root_1","for","destinationOrNext","destination","Subscriber","add","syncErrorThrowable","SafeSubscriber","subscriber","isStopped","_next","_error","_complete","Subscription_1","_parent","observerOrNext","bind","_context","__tryOrSetError","__tryOrUnsub","syncErrorValue","syncErrorThrown","parent","getSymbolObservable","subscribe","_subscribe","Observable","operator","source","sink","toSubscriber_1","PromiseCtor","Rx","config","Promise","resolve","reject","_this","observable_1","rate","rateText","console","log","AppComponent","EventEmitter","Object","RateComponent","val","rateVal","rateChange","emit","text","showLabel","isReadonly","readonly","String","preventDefault","rateMemo","__decorate","Output","Input","AppModule","NgModule","declarations","imports","BrowserModule","FormsModule","HttpModule","providers","bootstrap","platformBrowserDynamic","bootstrapModule"],"mappings":"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"}